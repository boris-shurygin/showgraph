\documentclass[11pt,twoside,a4paper]{article}
\usepackage{mathtext}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage[unicode,colorlinks=true, linkcolor=black]{hyperref}
\usepackage{tikz}
\usepackage{listings}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit}
\begin{document} 
\lstset{language=[Visual]C++}

\title{ShowGraph Internals.\\ \textsf{The Implementation Document}}
\author{Boris Shurygin}

\maketitle
\begin{abstract}
This document describes internal infrastructure of ShowGraph tool. ShowGraph is a simple graph editor which is capable of performing automatic layout for directed graphs. It is also capable of reading compiler dumps of control flow graphs allowing visualization of compiler IR. Currently GCC and ICC compilers are supported. This document gives a brief overview of ShowGraph's overall design and provides detailed description of the key components.
\end{abstract}
\tableofcontents
\section{Overview}
This section gives a brief overview of its internal structure. All the mentioned components have more detailed description in the \emph{``Key Components''} section.

As its name suggests the ShowGraph program is a tool for graph visualization. It is capable of showing a graph in interactive window and allows user to edit it, save it and load it. Additionally ShowGraph has parsers for ICC's and GCC's prints of intermediate representation to extract control flow graph from them. There are two versions of ShowGraph: interactive GUI version and command-line version for rendering graph from XML representation.

The components that interact with the user directly are GUI, command line parser and compiler IR parser which is called ``frontend'' in ShowGraph project. GUI of course is the most exposed to the user component. All graphical parts of ShowGraph are implemented inside it. It deals with things like windows, menus, buttons, toolbars and of course graphical representation of graph (call it graph view). GUI features are based on Qt library and graph view employs Qt's GraphicsView framework. Nodes and Edges are implemented as subclasses of QGraphicsItem class.

Of course QGraphicsView does not know anything about graph as a data structure and would not perform 2D graph layout for us. This functionality is implemented in \emph{layout} component which places nodes and routes edges to obtain a layout for graph.

The graph representation itself is implemented in \emph{graph} component. It deals with the graph that has set of nodes and edges, the node that has lists of predecessors and successors edges and the edge that has predecessor and successor nodes. The graph is based on low level tools such as lists and memory pools.

Memory pools are part of memory management framework. The only used type of memory pool at the moment is the fixed pool. This type of pool allows for fast allocation and deallocation of memory but works with entries of the same size. To create entries of different sizes one has to create specialized pool for each size.

There are some very low-level tools like lists, assertion macros and a singleton template that are use by other components. Lists are a family of classes that implement doubly-liked lists with usual prev/next pointers. 

Implementation language of ShowGraph is C++. External dependencies are Qt 4.5 library and Microsoft's runtime library for C++. ShowGraph is in active development process and changing rapidly. Things described in this document may change soon, but I'll try to keep the document consistent with the current state of ShowGraph sources.

\section{Key Components}
This section describes interfaces and key implementation aspects of ShowGraph's key components. Components are described in order of increasing complexity: from basic ones to the ones built above them.
\subsection{Intrusive data structures}
Several components in ShowGraph are implemented with use of intrusive data structures. These structures share one key feature: they store all pointers needed for their operation within the client objects. This is implemented via inheritance. Typical interface for these structure would be like this:
\begin{lstlisting}
/** Implementation */
class ListItem
{
    ListItem *next_p;
public:
    void setNext( ListItem *n) { next = n};
    ListItem *next() const { return next_p};
};
/** Interface */
template< class Data, class Base> class ListIface: public Base
{
public:
    Data *next() const
    {
        return static_cast< Data*>( ListItem::next())
    }
};
\end{lstlisting}
Here the ``\lstinline{class Base}'' parameter of template must be somehow derived from ListItem. To use this list user can inherit from this interface:
\begin{lstlisting}
/** Client code */
class Data: public ListIface< Data, ListItem> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
\end{lstlisting}
Lets discuss this example in detail. Class \lstinline{ListItem} implements simple intrusive one-way connected list. If we derive user class \lstinline{Data} from \lstinline{ListItem} directly we can make use of \lstinline{setNext(...)} method. But method \lstinline{next()} returns \lstinline{ListItem *} and user have to cast it to pointer to \lstinline{Data}. That's what interface class \lstinline{ListIface} was made for. Its intent was to avoid pushing programmer using the data structures to manually cast pointers in his code. It makes interface more elegant and saves a lot of effort. 

This could be achieved without separating interface from implementation. Interface of this merged structure would look like:
\begin{lstlisting}
/** Implementation */
template < class T> class ListItem
{
    T *next_p;
public:
    void setNext( T *n) { next = n};
    T *next() const { return next_p};
};
/** Client code */
class Data: public ListItem< Data> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
\end{lstlisting}
This achieves short term goal of making intrusive list of user objects. 

Complications arise when we derive some class from \lstinline{Data} class. In this case we would have to write casts anyway:
\begin{lstlisting}
/** Client code */
class Data: public ListItem< Data> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
/** Derived class */
class ComplexData: public Data
{
    /** Useful extending code */
public:
    ComplexData *next() const
    {
        return static_cast< ComplexData>( Data::next());
    }
};
\end{lstlisting}
Instead of doing this, separated interface can be inherited by derived class also.
\begin{lstlisting}
/** Client code */
class Data: public ListIface< Data, ListItem> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
/** Derived class */
class ComplexData: public ListIface< ComplexData, Data>
{
    /** Useful extending code */
public:
    /** 
     * Do not need to implement container-related routines
     */
};
\end{lstlisting}

This kind of design for intrusive data structures is used for list-related classes and for graphs.

\subsection{Tools}
Tools are placed in Utils project in ShowGraph's Visual Studio solution. They are used by other components of the system and form the basement of our application's architecture. Like every other level of ShowGraph's architecture they extensively use Qt libraries.


\subsubsection{Host Abstraction}
Host abstraction is not really a piece of code in this project. It is rather a convention, that for every primitive type we use appropriate Qt type. These types are available through \lstinline{#include <QtGlobal>} directive.

\subsubsection{Asserts}
There are two types of asserts in ShowGraph: template functions throwing exceptions and macros that just die with printing line number.

Most commonly used asserts are assert macros based on Qt's \lstinline{Q_ASSERT} and \lstinline{Q_ASSERT_X}. They are \lstinline{ASSERT( bool cond)}, \lstinline{ASSERTD( bool cond)}, and \lstinline{ASSERT_XD( cond, where, what)}. The difference between 'D' version and the macros without 'D' on the end is that \lstinline{ASSERT} stays in release mode and macros like \lstinline{ASSERTD} are removed from release code. 

Some modules define their own asserts. For example memory manager uses  \lstinline{MEM_ASSERTD( cond, what)} that reports error to happen in 'Memory Manager' and describes the error.

Function-based asserts are used for checking errors that do not cause application to die immediately and can be recovered by catching exception in proper place. They are intended for use in release code. However \lstinline{assertd( bool cond)} routine can be used for debug-only asserts.

\subsubsection{Lists}
There are three kinds of lists used in ShowGraph project:
\begin{description}
\item[ListItem] is a doubly-connected list that stores pointers to client data
\item[MListItem] is an intrusive multi-list element. List number is a template parameter. Like other intrusive data structures in ShowGraph it has corresponding interface \lstinline{MListIface}.
\item[SListItem] is a specialization of \lstinline{MListItem} for single list. Its corresponding interface template is \lstinline{SListIface}.
\end{description}

All of these lists have similar interface when working with list structure. Routines \lstinline{next()} and \lstinline{prev()} allows traversing the list in default directions. Routine \lstinline{next()} returns list element in default direction and \lstinline{prev()} returns list element in reverse direction. There are also interfaces like \lstinline{peerInDir(...)} that allows writing algorithms parameterized with traverse direction. 

One can connect and element into list by invoking \lstinline{attach(...)}. Alternatively if element is created with appropriate constructor it is also connected into list.

For \lstinline{MListItem} all these routines have additional parameter that specifies the list for this operations. An example usage of this list would be:
\begin{lstlisting}
/** See sources/Utils/list_utest.cpp for this code */
#include "utils_iface.h"

/** Define the lists we use */
enum ListTypes
{
    LIST_ONE,
    LIST_TWO,
    LISTS_NUM
};
/** Derive class of linked objects */
class A: public MListIface< A, MListItem<LISTS_NUM>, LISTS_NUM>
{

};
/** Derive class from A */
class B: public MListIface< B, A, LISTS_NUM>
{

};

/** MList testing */
static bool uTestMList()
{
    B *obj1 = new B();
    B *obj2 = new B();
    B *obj3 = new B();
    obj1->attach( LIST_ONE, obj2);
    obj1->attach( LIST_TWO, obj3);
    obj2->detachAll()
    delete obj2;
    delete obj1;
    delete obj3;
    return true;
}

\end{lstlisting}

\subsubsection{Singleton}
To provide means for creating unique objects of some class the template \lstinline{Single<class Unique>} was introduced. Its implemtation is slightly different from common implementations of Singleton programming pattern. The key difference is that creation and destruction of singleton object is not automatic with Single template. There are routines \lstinline{init()} and \lstinline{deinit()} for these purposes. 

Other aspects of implementation are conventional. A pointer to unique object can be obtained via \lstinline{instance()} routine. A pointer is a static member of Single object. 

Constructors, destructor and assignment of client object should be made private and instance of Single template should be made friend of the client class.

Here is an example of singleton usage:
\begin{lstlisting}
class A;
typedef Single< A> SingleA;

/** Sample class */
class A
{
private:
    /** private constructors, assignment and destructor */
    A(){};
    A( const A&){};
    A& operator =( const A&){};
    ~A(){};
    /** Needed for singleton creation */
    friend SingleA;
};
/** static assignment of 0 to instance pointer */
SINGLETON_INSTANCE( A);    

/**
 * Test simple singleton
 */
int main()
{
    SingleA::init();

    A* a1 = SingleA::instance();
    A* a2 = SingleA::instance();
    ASSERT( areEqP( a1, a2));
    SingleA::deinit();
    return 0;
}
\end{lstlisting}

This type of singleton is intended for objects that are inexpensive to create and do not occupy a lot of critical resources. Examples may be classes that implement logging, some statistics collection. Real example can be found in memory manager class that uses singleton-based implementation of counters for memory events like allocations and deallocations.

For single object that have expensive creation and destruction and we may not need that object in runtime, this type of singleton does not suit well. We don't have a real automatically-handled singleton implementation yet.

\subsection{Memory Managment Framework}
The key principle behind ShowGraph's memory management approach is that we mostly care for objects that can exits in large quantities. These objects are likely to benefit from allocation in pools. We can also allocate other objects in pools but this is not performance critical and if we do this - that would be for the purposes of enforcing leakage detection.

\subsubsection{Pools}
A \emph{memory pool} is a technique for managing application's memory needs by providing some additional functionality over standard library routines. One piece of memory allocated by a pool is called an \emph{entry}. All memory pools in ShowGraph project share the same interface: they allow for allocation of some memory piece and for deallocation of previously allocated one. By design pools are not suited for allocating arrays of objects since some kind of pools are not able to allocate enough ammount of continuous memory ( e.g. FixedPool have chunks with fixed number of entries). That's why \lstinline{operator new[]} is prohibited for pool-stored object (\lstinline{operator delete[]} is prohibited as well). Base class that defines pool interface is located in \lstinline{Mem} namespace and looks like:
\begin{lstlisting}
class Pool
{
    public:
        /** Allocate new memory block */
        virtual void* allocate( size_t size) = 0;
        /** Free memory block */
        virtual void deallocate( void *ptr) = 0;
        /** 
          * Functionality of 'operator delete'
          * for pooled objects
          */
        virtual void destroy( void *ptr) = 0;
};
\end{lstlisting}
Member methods are named quite straightforward: \lstinline{Pool::allocate} allocates entries, \lstinline{Pool::deallocate} performs deallocation and  \lstinline{Pool::destroy} calls object's destructor before calling  \lstinline{Pool::deallocate}. Pool-controlled objects must be derived from  \lstinline{PoolObj}.
\begin{lstlisting}
/**
 * Base class for all objects allocated in pools
 */    
class PoolObj
{
  public:
    /** Default operator 'new' is disabled */
    void *operator new ( size_t size);
    /** Default operator 'delete' is disabled */
    void operator delete( void *ptr);
    /** Default operator 'new' is disabled */
    void *operator new[] ( size_t size);
    /** Default operator 'delete' is disabled */
    void operator delete[] ( void *ptr);
       
    /** Placement new */
    inline void *operator new ( size_t size, Pool* pool);
    
    /**
     * Operator 'delete' corresponding to placement new
     * WARNING: Compiler won't call this for deletion. 
     *          It is needed for freeing memory in  
     *          case of exceptions in constructor
     */
    inline void operator delete( void *ptr, Pool* pool);
    
    /** To be called by 'destroy' routine of pool class */
    virtual ~PoolObj(){};
};
\end{lstlisting}
After derivation object of user class can be created like this:
\begin{lstlisting}
class MyClass: public PoolObj
{
   /* Some useful code */        
};

void somefunc( Pool *pool)
{
    MyClass *ptr = new ( pool) MyClass();
    pool->destroy( ptr); // Calls destructor
}
\end{lstlisting}

A \emph{Fixed pool} is a pool that creates entries of the same size which is defined by pool parameter. It uses the knowledge of the entry-size for optimization of allocation/deallocation process and for simplifying the internal bookkeeping. This simplification significantly speeds up pool's operation.

Fixed pools are created by instantiation of \lstinline{FixedPool< class Data>} template which implements interface of the \lstinline{Pool} class. The template parameter ``\lstinline{class Data}'' defines the user's object type which determines the pool's entry size.

Internal implementation of a fixed pool is based on allocating memory in so-called \emph{chunks}. A \emph{chunk} is a continuous block of memory which holds a number of entries and is allocated with one call to system. The allocated memory is managed by the pool and released to system when pool doesn't need it. This policy effectively avoids calling \lstinline{malloc/free} for every entry and prevents fragmentation. \lstinline{FixedPool} class trades off compactness for quickness and uses additional info for every entry. Every entry keeps:
\begin{itemize}
\item Its own number. To calculate pointer to chunk info from pointer to entry.
\item Number of next free entry in this chunk. For speeding up the allocation.
\item Debug info like allocation/deallocation event number or ``free'' flag for checking double deallocation.
\end{itemize}
The chunks are organized in doubly-liked list to have constant time for chunk creation/destruction. Free chunks are also linked in list to speed up the allocation. 

On allocation request pool simply gets its first free chunk and returns pointer to its first entry. On deallocation, pointer to chunk is calculated from pointer to entry using its own number and entry is simply connected to the head of free entry list in the chunk. The chunk itself is enrolled in the list of free chunks if it isn't already there. If the chunk is completely empty after this deallocation it may be deleted if there are other free chunks present. Both allocation and deallocation demand constant time unless we have to allocate a new chunk or free existing empty one.

To decrease memory usage overhead the numbers in entries are effectively one byte each. Thats two byte per entry overhead if we don't align entries on 8, 16, 32 or 64 bytes. Thus memory overhead is significant if we store small objects in such a pool but for a list unit this overhead is about 25\% and for graph's node or edge it is $\sim$6.2\%.

When project is built in debug mode the pools keep track of every entry's allocation and deallocation ID. This allows programmer to put in a breakpoint if a memory leak or double-delete occurred. The conditional breakpoint should be placed in \lstinline{MemInfo::allocReg( n)} or \lstinline{MemInfo::deallocReg( n)} where 'n' should be the ID that can be obtained from suspicious entry.

\subsubsection{Smart pointers}
Smart pointers are in the process of design now. They are not used in project at the moment. They are to be used for two purposes:
\begin{itemize}
\item Dangling pointer check
\item Reference counter implementation
\end{itemize}

There are still numerous open questions to be considered in smart pointers implementation. Should they be intrusive/external? Do they need to interact with pool's functionality? Should we allow conversion of smart pointer to plain pointer? How do we support conversions between smart pointers?

\subsection{Graph Representation}
Graph representation in ShowGraph has different aspects. Of course there are classes Graph, Edge and Node, but graph representation have some more features: it has built-in support for markers and numbering of nodes and edges. It can be also dumped to an XML file and read from it.

\subsubsection{Graph, Edges and Nodes}
Graph class represents graph as a set of nodes and edges. Graph has lists of nodes and edges which can be traversed by getting graph's first node or edge and using methods \lstinline{nextNode( node)} and \lstinline{nextEdge( edge)}. 

Graph has memory pools for nodes and edges. Operators \lstinline{new} and \lstinline{delete} are can't be applied to nodes and edges (constructors are also private).  They can be created by newNode and newEdge methods of graph. To destroy node or edge object one should use deleteNode/deleteEdge methods of graph. Using graph's methods instead of direct calls of \lstinline{new} and \lstinline{delete} is not only dictated by graph's pool system but also supports memory ownership concept: nodes' and edges' memory is owned by the graph.

As one would normally expect a node has pointers to adjacent edges. These pointers are divided in two groups: predecessors and successors. At the moment Showgraph supports directed graphs only. A node also has a unique ID that is used for storing graph in XML form and for debug purposes. This id is unique for all nodes of a graph, not only the once that are living at particular point in execution but for deleted nodes also, i.e. ID is never reused. A node has pointer to the graph so it can't belong to more than one graph. Since node is a list item in graph's node list one can traverse the list with nextNode method. Adjacent edges' lists can be obtained by firstPred() and firstSucc() methods.

An edge has a predecessor and successor (let's call them ``pred'' and ``succ'' for short). Note that if some edge $e$ has successor node $n$ this edge would be predecessor of $n$ and vice versa. Like a node an edge has its unique id and pointer to graph (which is redundant since pred and succ of node are valid pointers to nodes by design and graph can be obtained from any of them).

\subsubsection{Markers and Numerations}
Every node and edge can be marked and numbered. To do this one can acquire a marker or numeration from graph. When a marker is created there are no nodes/edges in graph marked with it. Same for a fresh numeration there are no node numbered with it. Number of simultaneously alive markers/numerations is limited so they should be freed after use.

Interfaces for markers and numerations are quite similar so let's see one of them: interface for using numeration. Numeration can be obtained from `NumManager' ( graph is a subclass of it) by method \lstinline{newNum}. One use it with the subclasses of `Numbered' class to number the objects (nodes/edges or some others). Routines for this are \lstinline{isNumbered}, \lstinline{number}, \lstinline{setNumber}, \lstinline{unNumber} and \lstinline{clear}. The latter both set the number to \emph{`unknown'} value but \lstinline{unNumber} says if an object was numbered in given numeration.

On low level numerations and markers are implemented as a pair: index and value. This is done to minimize cleaning frequency. Let's see how it works.

Markers can be implemented as a simple index to an array of booleans which store information about object being marked or not. In this case we would have to clean all objects once we are done with marker or leave it to the client classes. The first would be quite expensive: it could add another $N$ multiplier to complexity of algorithms that use markers. The second one is what we tried to avoid: forcing client classes to implement a bunch of copy paste code that would manage the markers and objects marked with them.

Instead of doing this we use an \emph{index} and a \emph{value}. To check if an object is marked we see if in markers array a proper position has corresponding value. A new value is created each time we create a marker and index is selected among free positions (that's why we have limited number of markers at any given execution point). We create new value by incrementing the last created value. We wipe out dead makers after we have reached the maximum of value variable capacity and start giving values from the beginning. Numerations are implemented in the same manner.


\subsubsection{XML representation}
\subsubsection{Subclassing Graph}


\subsection{Automatic Graph Layout}


\subsection{Frontend}


\subsection{GUI Implementation}


\section{Project Organization}
Currently ShowGraph is being developed for Windows using Visual Studio 2005. Therefore project is organized around VS solution. Other operating systems or build systems are not supported. This is likely to change in nearest future. There are plans of supporting Linux and using \emph{make} tool for building.

Lets see what's inside the MS VS solution. There are mainly four target projects in solution: `autodoc', `Gui', `Console' and `UnitTest'. `Autodoc' project uses \emph{Doxygen} tool to create documentation from source code. `Gui' and `Console' projects generate binaries for GUI and console versions of ShowGraph. GUI version is primary version for most users and console version is provided to enable using showgraph from console and in scripts for graph image generation. Console version is also supposed to be used in automated testing of ShowGraph's layout engine. `UnitTest' is supposed to be built and run as a sort of sanity check for tools and most packages if it exits with 0 the check is to be considered passed.


\subsection{Building}
Any of four targets can be built separately. Or one can build the whole solution to get them all.

To work with project one needs:
\begin{itemize}
\item MS Visual Studio 2005 ( or higher, but that was not tested)\
\item Subversion client. My personal favorite for Windows is TortoiseSVN http://tortoisesvn.net/
\end{itemize}

MSVS is of course `a must' at the moment as it is main development tool. There will be a choice once the projects supports gcc, make and others. SVN is needed to get the sources. Follow these steps to build the ShowGraph tools:
\begin{enumerate}
\item Install and build Qt http://qt.nokia.com/
\item Checkout sources from http://showgraph.googlecode.com/svn/trunk/
\item Add Qt directories `bin', `lib', and some `include' directories to VC++ directories in MS VS options
\item Run `Build Solution' in Visual Studio
\end{enumerate}

\subsection{Testing}
Due to lack of resources the testing process in not clearly defined. Up to this moment all testing was done by hand of developer without any standard procedure. There are no clearly stated quality requirements and formal process. Automated testing and semi-automated testing is described below.

\subsubsection{Unit Testing}
Components of showgraph have some unit testing. These tests are written as a sanity check and provide very basic quality check. In addition GUI is not really covered with unit tests.

These tests are run by building UnitTest project and running the resulting executable binary. These tests use asserts for checking. In case of failure application immediately crashes. Normal execution with 0 return code signals that all tests have passed.

\subsubsection{Automated Testing}
Automated testing is currently in its simple form: a testing script that runs console version of ShowGraph on a few xml tests.

\subsection{Distribution}
No setup application have been developed. ShowGraph is distributed via plain copying of binary + manifest file + Qt libraries.

\end{document}
