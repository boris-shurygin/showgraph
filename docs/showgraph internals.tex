\documentclass[11pt,twoside,a4paper]{article}
\usepackage{mathtext}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage[unicode,colorlinks=true, linkcolor=black]{hyperref}
\usepackage{tikz}
\usepackage{listings}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit}
\begin{document} 
\lstset{language=[Visual]C++}

\title{ShowGraph Internals.\\ \textsf{The Implementation Document}}
\author{Boris Shurygin}

\maketitle
\begin{abstract}
This document describes internal infrastructure of ShowGraph tool. ShowGraph is a simple graph editor which is capable of performing automatic layout for directed graphs. It is also capable of reading compiler dumps of control flow graphs allowing visualization of compiler IR. Currently GCC and ICC compilers are supported. This document gives a brief overview of ShowGraph's overall design and provides detailed description of the key components.
\end{abstract}
\tableofcontents
\section{Overview}
Showgraph architecture\ldots
\section{Key Components}
This section describes interfaces and key implementation aspects of ShowGraph's key components. Components are described in order of increasing complexity: from basic ones to the ones built above them.
\subsection{Intrusive data structures}
Several components in ShowGraph are implemented with use of intrusive data structures. These structures share one key feature: they store all pointers needed for their operation within the client objects. This is implemented via inheritance. Typical interface for these structure would be like this:
\begin{lstlisting}
/** Implementation */
class ListItem
{
    ListItem *next_p;
public:
    void setNext( ListItem *n) { next = n};
    ListItem *next() const { return next_p};
};
/** Interface */
template< class Data, class Base> class ListIface: public Base
{
public:
    Data *next() const
    {
        return static_cast< Data*>( ListItem::next())
    }
};
\end{lstlisting}
Here the ``\lstinline{class Base}'' parameter of template must be somehow derived from ListItem. To use this list user can inherit from this interface:
\begin{lstlisting}
/** Client code */
class Data: public ListIface< Data, ListItem> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
\end{lstlisting}
Lets discuss this example in detail. Class \lstinline{ListItem} implements simple intrusive one-way connected list. If we derive user class \lstinline{Data} from \lstinline{ListItem} directly we can make use of \lstinline{setNext(...)} method. But method \lstinline{next()} returns \lstinline{ListItem *} and user have to cast it to pointer to \lstinline{Data}. That's what interface class \lstinline{ListIface} was made for. Its intent was to avoid pushing programmer using the data structures to manually cast pointers in his code. It makes interface more elegant and saves a lot of effort. 

This could be achieved without separating interface from implementation. Interface of this merged structure would look like:
\begin{lstlisting}
/** Implementation */
template < class T> class ListItem
{
    T *next_p;
public:
    void setNext( T *n) { next = n};
    T *next() const { return next_p};
};
/** Client code */
class Data: public ListItem< Data> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
\end{lstlisting}
This achieves short term goal of making intrusive list of user objects. 

Complications arise when we derive some class from \lstinline{Data} class. In this case we would have to write casts anyway:
\begin{lstlisting}
/** Client code */
class Data: public ListItem< Data> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
/** Derived class */
class ComplexData: public Data
{
    /** Useful extending code */
public:
    ComplexData *next() const
    {
        return static_cast< ComplexData>( Data::next());
    }
};
\end{lstlisting}
Instead of doing this, separated interface can be inherited by derived class also.
\begin{lstlisting}
/** Client code */
class Data: public ListIface< Data, ListItem> 
{
    int a;
public:
    void setA( int a_){ a= a_;}
	 int getA() { return a;}
};
/** Derived class */
class ComplexData: public ListIface< ComplexData, Data>
{
    /** Useful extending code */
public:
    /** 
     * Do not need to implement container-related routines
     */
};
\end{lstlisting}

This kind of design for intrusive data structures is used for list-related classes and for graphs.

\subsection{Tools}
Tools are placed in Utils project in ShowGraph's Visual Studio solution. They are used by other components of the system and form the basement of our application's architecture. Like every other level of ShowGraph's architecture they extensively use Qt libraries.


\subsubsection{Host Abstraction}
Host abstraction is not really a piece of code in this project. It is rather a convention, that for every primitive type we use appropriate Qt type. These types are available through \lstinline{#include <QtGlobal>} directive.

\subsubsection{Asserts}
There are two types of asserts in ShowGraph: template functions throwing exceptions and macros that just die with printing line number.

Most commonly used asserts are assert macros based on Qt's \lstinline{Q_ASSERT}. They are \lstinline{ASSERT( bool cond)} and \lstinline{ASSERTD( bool cond)}. The difference between them is that \lstinline{ASSERT} stays in release mode and \lstinline{ASSERTD} is removed from release code. 

Function-based asserts are used for checking errors that do not cause application to die immediately and can be recovered by catching exception in proper place. They are intended for use in release code. However \lstinline{assertd( bool cond)} routine can be used for debug-only asserts.

\subsubsection{Lists}
There are three kinds of lists used in ShowGraph project:
\begin{description}
\item[ListItem] is a doubly-connected list that stores pointers to client data
\item[MListItem] is an intrusive multi-list element. List number is a template parameter. Like other intrusive data structures in ShowGraph it has corresponding interface \lstinline{MListIface}.
\item[SListItem] is a specialization of \lstinline{MListItem} for single list. Its corresponding interface template is \lstinline{SListIface}.
\end{description}

All of these lists have similar interface when working with list structure. Routines \lstinline{next()} and \lstinline{prev()} allows traversing the list in default directions. Routine \lstinline{next()} returns list element in default direction and \lstinline{prev()} returns list element in reverse direction. There are also interfaces like \lstinline{peerInDir(...)} that allows writing algorithms parameterized with traverse direction. 

One can connect and element into list by invoking \lstinline{attach(...)}. Alternatively if element is created with appropriate constructor it is also connected into list.

For \lstinline{MListItem} all these routines have additional parameter that specifies the list for this operations. An example usage of this list would be:
\begin{lstlisting}
/** See sources/Utils/list_utest.cpp for this code */
#include "utils_iface.h"

/** Define the lists we use */
enum ListTypes
{
    LIST_ONE,
    LIST_TWO,
    LISTS_NUM
};
/** Derive class of linked objects */
class A: public MListIface< A, MListItem<LISTS_NUM>, LISTS_NUM>
{

};
/** Derive class from A */
class B: public MListIface< B, A, LISTS_NUM>
{

};

/** MList testing */
static bool uTestMList()
{
    B *obj1 = new B();
    B *obj2 = new B();
    B *obj3 = new B();
    obj1->attach( LIST_ONE, obj2);
    obj1->attach( LIST_TWO, obj3);
    obj2->detachAll()
    delete obj2;
    delete obj1;
    delete obj3;
    return true;
}

\end{lstlisting}
\subsection{Memory Managment Framework}
The key principle behind ShowGraph's memory management approach is that we mostly care for objects that can exits in large quantities. These objects are likely to benefit from allocation in pools. We can also allocate other objects in pools but this is not performance critical and if we do this - that would be for the purposes of enforcing leakage detection.

\subsubsection{Pools}
A \emph{memory pool} is a technique for managing application's memory needs by providing some additional functionality over standard library routines. One piece of memory allocated by a pool is called an \emph{entry}. All memory pools in ShowGraph project share the same interface: they allow for allocation of some memory piece and for deallocation of previously allocated one. By design pools are not suited for allocating arrays of objects since some kind of pools are not able to allocate enough ammount of continuous memory ( e.g. FixedPool have chunks with fixed number of entries). That's why \lstinline{operator new[]} is prohibited for pool-stored object (\lstinline{operator delete[]} is prohibited as well). Base class that defines pool interface is located in \lstinline{Mem} namespace and looks like:
\begin{lstlisting}
class Pool
{
    public:
        /** Allocate new memory block */
        virtual void* allocate( size_t size) = 0;
        /** Free memory block */
        virtual void deallocate( void *ptr) = 0;
        /** 
          * Functionality of 'operator delete'
          * for pooled objects
          */
        virtual void destroy( void *ptr) = 0;
};
\end{lstlisting}
Member methods are named quite straightforward: \lstinline{Pool::allocate} allocates entries, \lstinline{Pool::deallocate} performs deallocation and  \lstinline{Pool::destroy} calls object's destructor before calling  \lstinline{Pool::deallocate}. Pool-controlled objects must be derived from  \lstinline{PoolObj}.
\begin{lstlisting}
/**
 * Base class for all objects allocated in pools
 */    
class PoolObj
{
  public:
    /** Default operator 'new' is disabled */
    void *operator new ( size_t size);
    /** Default operator 'delete' is disabled */
    void operator delete( void *ptr);
    /** Default operator 'new' is disabled */
    void *operator new[] ( size_t size);
    /** Default operator 'delete' is disabled */
    void operator delete[] ( void *ptr);
       
    /** Placement new */
    inline void *operator new ( size_t size, Pool* pool);
    
    /**
     * Operator 'delete' corresponding to placement new
     * WARNING: Compiler won't call this for deletion. 
     *          It is needed for freeing memory in  
     *          case of exceptions in constructor
     */
    inline void operator delete( void *ptr, Pool* pool);
    
    /** To be called by 'destroy' routine of pool class */
    virtual ~PoolObj(){};
};
\end{lstlisting}
After derivation object of user class can be created like this:
\begin{lstlisting}
class MyClass: public PoolObj
{
   /* Some useful code */        
};

void somefunc( Pool *pool)
{
    MyClass *ptr = new ( pool) MyClass();
    pool->destroy( ptr); // Calls destructor
}
\end{lstlisting}

A \emph{Fixed pool} is a pool that creates entries of the same size which is defined by pool parameter. It uses the knowledge of the entry-size for optimization of allocation/deallocation process and for simplifying the internal bookkeeping. This simplification significantly speeds up pool's operation.

Fixed pools are created by instantiation of \lstinline{FixedPool< class Data>} template which implements interface of the \lstinline{Pool} class. The template parameter ``\lstinline{class Data}'' defines the user's object type which determines the pool's entry size.

Internal implementation of a fixed pool is based on allocating memory in so-called \emph{chunks}. A \emph{chunk} is a continuous block of memory which holds a number of entries and is allocated with one call to system. The allocated memory is managed by the pool and released to system when pool doesn't need it. This policy effectively avoids calling \lstinline{malloc/free} for every entry and prevents fragmentation. \lstinline{FixedPool} class trades off compactness for quickness and uses additional info for every entry. Every entry keeps:
\begin{itemize}
\item Its own number. To calculate pointer to chunk info from pointer to entry.
\item Number of next free entry in this chunk. For speeding up the allocation.
\item Debug info like allocation/deallocation event number or ``free'' flag for checking double deallocation.
\end{itemize}
The chunks are organized in doubly-liked list to have constant time for chunk creation/destruction. Free chunks are also linked in list to speed up the allocation. 

On allocation request pool simply gets its first free chunk and returns pointer to its first entry. On deallocation pointer to chunk is calculated from pointer to entry using its own number and entry is simply connected to the head of free entry list in the chunk. The chunk itself is enrolled in the list of free chunks if it isn't already there. If the chunk is completely empty after this deallocation it may be deleted if there are other free chunks present. Both allocation and deallocation demand constant time unless we have to allocate a new chunk or free existing empty one.

To decrease memory usage overhead the numbers in entries are effectively one byte each. Thats two byte per entry overhead if we don't align entries on 8, 16, 32 or 64 bytes. Thus memory overhead is significant if we store small objects in such a pool but for a list unit this overhead is about 25\% and for graph's node or edge it is $\sim$6.2\%.

\subsubsection{Smart pointers}


\subsection{Graph Representation}


\subsection{Automatic Graph Layout}


\subsection{Frontend}


\subsection{GUI Implementation}


\section{Project Organization}


\subsection{Building}


\subsection{Unit Testing}


\subsection{Distribution}


\end{document}
